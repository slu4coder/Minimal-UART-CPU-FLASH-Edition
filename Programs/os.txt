; ****************************************************************************
; *****                                                                  *****
; ***** MinOS 1.5 for the 8-Bit Minimal Computer System Revision 1.3-1.5 *****
; *****                                                                  *****
; *****      written by Carsten Herting - last update Apr 22th 2021      *****
; *****                                                                  *****
; ****************************************************************************
; Usage for in-situ programming: Open command shell, type 'asm os.txt', upload
; image via terminal to 0xe000 - 0xefff, load prom, type 8000 r, enjoy new OS.

; **************************************************************************
; Creates a file header for a non-deletable OS image and copies the OS image
; **************************************************************************
                  0                                            ; NOP mimics a non-deletable empty filename
                LDI <OS_SOURCE STA 0xfffc                      ; prepare OS image address at 0xfffc/d
                CLB 0xfffd
                CLB 0xfffe                                     ; prepare OS target address at 0xfffe/f
                LDI 0xf0 STA 0xffff
                JPA imcopyloop
                  0xf000, 0x0fe8                               ; mimics startadr and bytesize (uses 4KB for OS image)
  imcopyloop:   LDR 0xfffc STR 0xfffe                          ; copy the OS image
                INW 0xfffc INW 0xfffe
                LDA 0xffff CPI >OS_END BCC imcopyloop          ; has the OS code been copied?
                LDA 0xfffe CPI <OS_END BCC imcopyloop

; ************************
; START OF THE MINOS IMAGE
; ************************
                OS_SOURCE:                                     ; OS image starts HERE
  #end                                                         ; suppress change of data input address...
  #org 0xf000                            											 ; ... but assemble for this destination
  #begin
              
  _Start:       JPA OS_Start                                   ; MINOS JUMP TABLE
  _Prompt:      JPA OS_Prompt
  _Print:       JPA OS_Print
  _PrintHex:    JPA OS_PrintHex
  _WaitUART:    JPA OS_WaitUART
  _LoadFile:    JPA SSD_LoadFile
  _SaveFile:    JPA SSD_SaveFile

  OS_Start:     LDI 0xfe STA 0xffff                            ; stack init
                
                LDI <hometxt PHS LDI >hometxt                  ; print the OS splash screen
                PHS JPS OS_Print PLS PLS
                JPS OS_DrawLine JPS OS_PrintEnter
                LDI <starttxt PHS LDI >starttxt
                PHS JPS OS_Print PLS PLS
                JPS OS_DrawLine JPS OS_PrintEnter
                
  OS_Prompt:	  LDA OS_MemAddr+1 PHS JPS OS_PrintHex PLS       ; schreibe die aktuelle examine-Adresse
                LDA OS_MemAddr+0 PHS JPS OS_PrintHex PLS
                JPS OS_PrintSpace
                JPS OS_ReadLine                     ; get a line of input until ENTER or end of string is hit
                JPS preset                          ; reset parsing variables and pointers
                CLB OS_Mode                         ; start with monitor mode = 0					
  parsing:      LDR OS_ParsePtr                     ; ***** BYTE-BY-BYTE PARSING OF THE LINE INPUT *****
                CPI 'l' BEQ OS_LoadFile             ; COMMANDS
                CPI 's' BEQ OS_SaveFile
                CPI 'z' BEQ OS_ZapFile
                CPI 't' BEQ OS_DirTable
                CPI 'w' BEQ OS_WipeSSD
                CPI 'i' BEQ OS_Disasm
                CPI 'v' BEQ OS_HexFill
                CPI 'k' BEQ OS_HexCopy
                CPI 'n' BEQ OS_Bank
                CPI 'm' BEQ OS_Menu
                CPI 'r' BEQ OS_Run
                CPI ':' BEQ doppel                  ; : switch to 'deposit' mode
                CPI '.' BEQ punkt                   ; . switch to 'list' mode                    
                CPI 'a' BCS sletter                 ; a..f for hex numbers
                CPI 'A' BCS bletter		              ; A..Z for letters
                CPI '0' BCS zahl                    ; 0..9 for numbers
                  LDA OS_ParseNum+2                 ; interpretiere Zeichen als GO! according to mode (hier ' ' oder ENTER)
                  CPI 0 BEQ validdata               ; prüfe, ob überhaupt valide parse-Daten vorliegen
                    LDA OS_PtrB+0           				; KEINE VALIDEN DATEN!
                    CPI <OS_PtrC           				  ; prüfe ob ein unvollständiger mnemonic vorliegt
                    BEQ nohalfinp
                      JPS OS_PrintError        			; schreibe ? für mnemonic-Fehler
  nohalfinp:          JPA clrparsed
  OS_Menu:      LDI <menutxt PHS LDI >menutxt PHS
                JPS OS_Print PLS PLS
                JPA OS_Prompt
  OS_Run:				INB OS_ParsePtr
                JPR OS_MemAddr                      ; r => jumps immediately to OS_MemAddr
  doppel:       LDI 1 JPA setmode                   ; : => umschalten auf DEPOSIT OS_Mode=1
  punkt:          LDI 2                             ; . => umschalten auf LIST OS_Mode
    setmode:	  STA OS_Mode
                LDA OS_ParseNum+2                   ; validen input vorhergehend . oder : als 'OS_MemAddr' übernehmen
                CPI 0 BNE clrparsed                 ; liegt valider input vor?
    setmemadr:    LDA OS_ParseNum STA OS_MemAddr    ; validen Daten -> OS_MemAddr
                  LDA OS_ParseNum+1 STA OS_MemAddr+1
                  JPA clrparsed									    ; . : kam ohne valide Addresse davor
  bletter:      STR OS_PtrB                         ; Gross-Zeichen X speichern
                LDI 0xf0 STA OS_ParseNum+2           ; jede Eingabe X entwertet OS_ParseNum, da Teil einer ungeprüften Instr.
                INB OS_PtrB+0
                CPI <OS_PtrD                        ; Ende erreicht? (<OS_PtrC + 3 geht leider nicht)
                BCC parsed                          ; noch nicht -> erstmal ist alles getan
                  CLW OS_ParseNum                   ; XXX input vorhanden, opcode-Zähler rücksetzen
                  LDI <OS_PtrC STA OS_PtrB+0        ; set OS_PtrB schon wieder auf Empfang
  fitsuchen:      LDI <mnemonics STA OS_PtrB+0      ; pointer to start of table
                  LDI >mnemonics STA OS_PtrB+1
                  LDA OS_ParseNum ADW OS_PtrB
                  LDA OS_ParseNum ADW OS_PtrB
                  LDA OS_ParseNum ADW OS_PtrB
                  LDA OS_PtrC+0                     ; Abgleich 1. letter
                  CPR OS_PtrB
                  BNE opnotfit
                    INW OS_PtrB
                    LDA OS_PtrC+1                   ; Abgleich 2. letter
                    CPR OS_PtrB
                    BNE opnotfit
                      INW OS_PtrB
                      LDA OS_PtrC+2                 ; Abgleich 3. letter
                      CPR OS_PtrB
                      BEQ opfits
    opnotfit:           INB OS_ParseNum             ; teste nächsten mnemonic
                        CPI 64                      ; alle opcodes durchgeschaut?
                        BCC fitsuchen
                          JPS OS_PrintError
                          JPA clrparsed             ; opcode war nicht dabei -> parse-Daten verwerfen
    opfits:       CLB OS_ParseNum+2                 ; validate parsed number by hand
                  JPA parsed
    sletter:    SBI 39                              ; parse one byte normal hex input
    zahl:       SBI 48
                PHS
                LDI 4 STA OS_Count                  ; shift existing hex data to the left
    shiftloop:    LDA OS_ParseNum+0 LSL STA OS_ParseNum+0
                  LDA OS_ParseNum+1 ROL STA OS_ParseNum+1
                  LDA OS_ParseNum+2 ROL STA OS_ParseNum+2   ; this automatically validates a parsed number
                DEB OS_Count
                BNE shiftloop
                  PLS ADB OS_ParseNum               ; add new hex nibble to the right
                  JPA parsed
    clrparsed:  JPS preset                          ; ***** ENDE DES PARSINGS (AUCH MEHRERER BYTES) *****
    parsed:     LDR OS_ParsePtr                     ; ENDE DES PARSINGS EINES BYTES
                CPI 10                              ; prüfe hier NOCHMAL auf ENTER wg. Zeilenende
                BEQ OS_Prompt                       ; Zeilenende -> warten auf eine neue Zeile
                  INB OS_ParsePtr                   ; gehe zum nächsten Zeichen des Puffers
                  BCS OS_ErrorPrompt                ; Zeile zu lang? -> ERROR
                    JPA parsing                     ; nächstes byte aus input parsen
    preset:     CLW OS_ParseNum                     ; clear parsed number
                LDI 0xf0 STA OS_ParseNum+2          ; invalidate parsed number
                LDI <OS_PtrC STA OS_PtrB+0          ; reset pointer to start of mnemonic input string
                LDI >OS_PtrC STA OS_PtrB+1
                RTS
  validdata:      LDA OS_Mode                       ; ***** ES LIEGT EIN VALIDES PARSE-DATUM VOR *****
                  DEC
                  BCC setmemadr                     ; OS_Mode=0 -> übernimm Daten als einfache neue OS_MemAddr
                  BEQ mode_deposit                  ; OS_Mode=1 -> übernimm Daten als 'deposit'
  mode_list:      LDA OS_MemAddr+0 STA OS_PtrA+0    ; OS_Mode=2 -> Daten sind 'list until', print list
                  LDA OS_MemAddr+1 STA OS_PtrA+1    ; kopiere OS_MemAddr zum Benutzen
  startlistpage:  LDI 24 STA OS_PtrC                ; reuse as line counter
  startlistline:  LDI 16 STA OS_Count               ; init: 16 bytes pro Zeile
                  LDA OS_PtrA+1 PHS JPS OS_PrintHex PLS  ; Drucke aktuelle list-Adresse
                  LDA OS_PtrA+0 PHS JPS OS_PrintHex PLS
                  JPS OS_PrintSpace
                  JPS OS_PrintSpace
  nextlist:       LDR OS_PtrA PHS JPS OS_PrintHex PLS    ; Speicherinhalt drucken
                  JPS OS_PrintSpace
                  LDA OS_PtrA+0
                  CPA OS_ParseNum+0
                  BNE listweiter
                    LDA OS_PtrA+1
                    CPA OS_ParseNum+1
                    BNE listweiter  
                      JPS OS_PrintEnter             ; die Liste wurde vollständig gedruckt
                      JPA clrparsed
  listweiter:     INW OS_PtrA
                  DEB OS_Count
                  CPI 8 BNE notmiddle
                    JPS OS_PrintSpace               ; print an extra space after 8 bytes
  notmiddle:      CPI 0 BNE nextlist
                    JPS OS_PrintEnter
                    DEB OS_PtrC                     ; reuse as line counter
                    BNE startlistline
  listreadchar:       INP BEQ listreadchar
                      CPI 'q' BNE startlistpage     ; warte auf Tastendruck
                      JPA clrparsed
  mode_deposit: LDA OS_ParseNum                     ; validen Daten -> deposit
                STR OS_MemAddr
                INW OS_MemAddr                          
                JPA clrparsed

; ************************************************************************************************************************

; *******************
; Helpful subroutines
; *******************
OS_PrintSpace:      LDI ' ' JPA printchar

  OS_PrintError:    LDI '?' OUT JPS _WaitUART
  OS_PrintEnter:    LDI 10
    printchar:      OUT JPS _WaitUART
                    RTS

  OS_ErrorPrompt:   JPS OS_PrintError                     ; display error '?' and goto WOZMON newline input
                    JPA OS_Prompt

  OS_DrawLine:      JPS dl_plus                           ; draw +---------+ line for splash screen
                    LDI 38 STA OS_Count
    dl_loop:        LDI '-' OUT JPS _WaitUART
                    DEB OS_Count BNE dl_loop
    dl_plus:        LDI '+' OUT JPS _WaitUART
                    RTS


; **************************
; Ask user a yes/no question
; push: ---
; pull: key
; success: key = 'y'
; **************************
  OS_AreYouSure:    LDI <suretext PHS LDI >suretext PHS
                    JPS OS_Print PLS PLS
    ays_wait:       INP BEQ ays_wait
                    STS 3 RTS

; *********************************************************************************
; Reading in keyboard input into OS_InpBuf until <ENTER> is hit or string is filled
; *********************************************************************************
OS_ReadLine:  JPS readexit                            ; resets the LSB of OS_ParsePtr
  readchar:   INP BEQ readchar                        ; FAST testing (reading/clearing must happen within 616 cycles of receiving)
                OUT                                   ; 4 output without waiting, since the maximum receive rate is 115.2kHz anyway
                STR OS_ParsePtr                       ; 10
                CPI 10 BEQ readexit                   ; 10 teste auf ENTER & BACKSPACE
                BCS nobackspace                       ; 6(5) ... backspace wäre '8'
                  DEB OS_ParsePtr                     ; 10 BACKSPACE war's
                  CPI <OS_InpBuf                      ; 5
                  BCS readchar                        ; 6(5)
                    NOP NOP NOP NOP NOP NOP NOP       ; 112
                    LDI 32 OUT                        ; 8 backspace kompensieren (siehe auch nä. Zeile), JPS _WaitUART ist nicht nötig
  nobackspace:    INB OS_ParsePtr                     ; 10 kompensiert auch den line pointer
                  BCC readchar                        ; 6(5) maximale Anzahl von Zeichen wurde eingelesen
  readexit:         LDI >OS_InpBuf STA OS_ParsePtr+1  ; 12 reset the line pointer
                    LDI <OS_InpBuf STA OS_ParsePtr+0  ; 12                 
                    NOP NOP NOP NOP NOP NOP           ; 96
                    RTS                               ; 14

; ********************************************************************************************
; Parses hex number 0x0-0xffff from OS_ParsePtr into OS_ParseNum
; A valid number was parsed if OS_ParseNum+2 contains 0x00, otherwise 0xf0
; ********************************************************************************************
OS_ParseHexNum: CLW OS_ParseNum+0
                JPS pninvalidate
  pnreadchar:   LDR OS_ParsePtr                 ; input string lesen
                CPI 10 BEQ pnreturn             ; ENTER? -> immer zurück (wenn noch nichts da mit Fehler)
                CPI 'g' BCS pninvalidate        ; above f? -> melde Fehler!
                CPI 'a' BCS pnletter            ; a...f?
                CPI ':' BCS pnnotnum            ; above 9? -> Separator: Zurück, wenn was da ist, sonst übergehen.
                CPI '0' BCS pnzahl              ; 0...9?
                  JPA pnnotnum                  ; unter 0? -> Separator: Zurück, wenn was da ist, sonst übergehen.
  pnletter:     SBI 39                          ; parse one byte normal hex input, a = 10
  pnzahl:       SBI 48
                STS 0                           ; gelesenen Wert zwischenspeichern
                LDI 4 STA OS_Count              ; shift existing hex data 4 steps to the left
  pnshiftloop:  LDA OS_ParseNum+0 LSL STA OS_ParseNum+0
                LDA OS_ParseNum+1 ROL STA OS_ParseNum+1
                LDA OS_ParseNum+2 ROL STA OS_ParseNum+2
                DEB OS_Count BNE pnshiftloop
                  LDS 0 ADB OS_ParseNum+0       ; add new hex nibble (carry cannot happen)
                  JPA pnnext
  pnnotnum:     LDA OS_ParseNum+2               ; haben wir noch nix?
                CPI 0xf0 BNE pnreturn           ; dann weitermachen, sonst zurück mit Wert
  pnnext:         INB OS_ParsePtr               ; move along the input string
                  BCC pnreadchar                ; read more if string end was NOT reached
  pninvalidate: LDI 0xf0 STA OS_ParseNum+2      ; place 'not successful' in upper nibble (will be shifted during parsing)
  pnreturn:     RTS
  
; ********************************************************************************************
; Schreibt einen nullterminierten String at <stradr>
; push: stradr_lsb, stradr_msb
; pull: --, --
; ********************************************************************************************
OS_Print:       LDS 4 STA printaddr+0           ; get string pointer LSB
                LDS 3 STA printaddr+1           ; get string pointer MSB
  printloop:    LDA
  printaddr:    0xffff                          ; self-modifying code
                CPI 0 BEQ printend
            	    OUT
                  LDI 11                        ; waiting loop
  printwait:      DEC BNE printwait             ; with duration = 3 + n * 11 cycles
        		      INW printaddr
     		          JPA printloop
  printend:	    RTS

; ****************************************************
; Prints out a byte value <val> in HEX format
; push: <val>
; pull: --
; ****************************************************
OS_PrintHex: 	  LDS 3                           ; read value from stack
                LSR LSR LSR LSR								
                ADI '0'
                CPI 58 BCC Hex8msn
                  ADI 39                        ; mache einen Buchstaben draus
  Hex8msn:			OUT NOP NOP NOP NOP             ; min. 160 cycles bis zum nächsten UART send
                LDS 3
                LSL LSL LSL LSL LSR LSR LSR LSR
                ADI '0'
                CPI 58 BCC Hex8lsn
                  ADI 39
  Hex8lsn:			OUT
                LDI 13                          ; waiting loop
  phex_wait:    DEC BNE phex_wait               ; with duration = 3 + n * 11 cycles
                RTS

; *********************************************************************************
; Waits for a UART transmission to complete when called via API (164 including out)
; *********************************************************************************
OS_WaitUART:    LDI 11
  wuart_loop:   DEC BNE wuart_loop              ; with duration = 3 + n * 11 cycles
                RTS

; ***************************************************************
; COMMAND 'Memory filler', copies byte value into block of memory
; ***************************************************************
OS_HexFill:   INB OS_ParsePtr
              JPS OS_ParseHexNum
              LDR OS_ParsePtr CPI 10 BEQ OS_ErrorPrompt             ; wurde zu früh ENTER gedrückt?
              LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorPrompt            ; wurde eine Zahl eingelesen?
                LDA OS_ParseNum+1 STA OS_PtrA+1 LDA OS_ParseNum+0 STA OS_PtrA+0 ; copy 'from'
                JPS OS_ParseHexNum
                LDR OS_ParsePtr CPI 10 BEQ OS_ErrorPrompt           ; Test wie oben
                LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorPrompt
                  LDA OS_ParseNum+1 STA OS_PtrB+1 LDA OS_ParseNum+0 STA OS_PtrB+0    ; copy 'to'
                  JPS OS_ParseHexNum
                  LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorPrompt        ; Test wie oben
  mfnext:           LDA OS_ParseNum+0 STR OS_PtrA                   ; BESCHREIBE DEN SPEICHER
                    LDA OS_PtrA+0
                    CPA OS_PtrB+0
                    BNE mfweiter
                      LDA OS_PtrA+1
                      CPA OS_PtrB+1
                      BEQ OS_Prompt
  mfweiter:             INW OS_PtrA
                        JPA mfnext
           
; ***************************************
; COMMAND 'Memory block copy A..B -> C..'
; ***************************************
OS_HexCopy:   INB OS_ParsePtr
              JPS OS_ParseHexNum
              LDR OS_ParsePtr CPI 10 BEQ OS_ErrorPrompt             ; wurde zu früh ENTER gedrückt?
                LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorPrompt          ; wurde eine Zahl eingelesen?
                  LDA OS_ParseNum+1 STA OS_PtrA+1 LDA OS_ParseNum+0 STA OS_PtrA+0    ; copy source first -> A
              JPS OS_ParseHexNum
              LDR OS_ParsePtr CPI 10 BEQ OS_ErrorPrompt             ; Test wie oben
                LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorPrompt
                  LDA OS_ParseNum+1 STA OS_PtrB+1 LDA OS_ParseNum+0 STA OS_PtrB+0    ; copy source last -> B
                  JPS OS_ParseHexNum
                  LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorPrompt        ; Test wie oben
                  LDA OS_ParseNum+1 STA OS_PtrC+1 LDA OS_ParseNum+0 STA OS_PtrC+0    ; copy destination -> C                
  mcnext:           LDR OS_PtrA STR OS_PtrC									        ; copy from -> to
										LDA OS_PtrB+0 CPA OS_PtrA+0
                    BNE mcweiter
                      LDA OS_PtrB+1 CPA OS_PtrA+1
                      BEQ OS_Prompt
  mcweiter:             INW OS_PtrA INW OS_PtrC
												JPA mcnext

; **********************
; COMMAND 'Disassembler'
; **********************
OS_Disasm:    INB OS_ParsePtr
              JPS OS_ParseHexNum
              LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorPrompt            ; wurde eine Zahl eingelesen?
                LDA OS_ParseNum+1 STA OS_PtrA+1 LDA OS_ParseNum+0 STA OS_PtrA+0 ; copy 'start'                
  disstartpage: LDI 24 STA OS_Count
  disnextline:  LDA OS_PtrA+1 PHS JPS OS_PrintHex PLS               ; Drucke aktuelle list-Adresse
                LDA OS_PtrA+0 PHS JPS OS_PrintHex PLS
                JPS OS_PrintSpace
                LDI <mnemonics STA OS_PtrB+0 LDI >mnemonics STA OS_PtrB+1   ; point OS_PtrB to lookup
                LDR OS_PtrA
                CPI 0x40
                BCC disinstruct
                  LDI '?' OUT JPS _WaitUART
                  JPA finishline
  disinstruct:  LSL ADR OS_PtrA ADW OS_PtrB                         ; PRINT INSTRUCTION
                LDR OS_PtrB OUT JPS _WaitUART INW OS_PtrB           ; output the XXX mnemonic
                LDR OS_PtrB OUT JPS _WaitUART INW OS_PtrB
                LDR OS_PtrB OUT JPS _WaitUART
                JPS OS_PrintSpace
                LDI <oplength STA OS_PtrB+0 LDI >oplength STA OS_PtrB+1   ; point OS_PtrB to lookup
                LDR OS_PtrA ADW OS_PtrB
                LDR OS_PtrB                                         ; retrieve length of operand
                CPI 0 BEQ finishline
                CPI -1 BEQ disminus
                CPI 1 BEQ disone
  distwo:         LDI 2 ADW OS_PtrA
                  LDR OS_PtrA PHS JPS OS_PrintHex PLS
                  DEW OS_PtrA
                  LDR OS_PtrA PHS JPS OS_PrintHex PLS
                  INW OS_PtrA
                  JPA finishline
  disminus:       INW OS_PtrA
                  LDI '-' OUT JPS _WaitUART
                  LDR OS_PtrA NEG PHS JPS OS_PrintHex PLS
                  JPS finishline  
  disone:         INW OS_PtrA
                  LDR OS_PtrA PHS JPS OS_PrintHex PLS
  finishline:   INW OS_PtrA
                JPS OS_PrintEnter
                DEB OS_Count
                BNE disnextline
  disreadchar:    INP BEQ disreadchar
                  CPI 'q' BNE disstartpage                          ; warte auf Tastendruck
                  JPA OS_Prompt

; ***********************************************
; COMMAND 'Format' (or SSD Format 4KB Block only)
; ***********************************************
OS_Bank:      INB OS_ParsePtr
              JPS OS_ParseHexNum                                    ; parse the input line
              LDA OS_ParseNum+2 CPI 0xf0 BEQ OS_ErrorPrompt         ; wurde eine Zahl eingelesen (0x00) oder nicht (0xf0)
                LDA OS_ParseNum+0 CPI 0x10 BCS OS_ErrorPrompt
                BNK
                JPA OS_Prompt

; ***********************************************
; COMMAND 'Format' (or SSD Format 4KB Block only)
; ***********************************************
OS_WipeSSD:   PHS JPS OS_AreYouSure PLS
              CPI 'y' BNE OS_Prompt
                INB OS_ParsePtr
                JPS OS_ParseHexNum                              ; parse the input line
                LDA OS_ParseNum+2 CPI 0xf0 BEQ format_all       ; wurde eine Zahl eingelesen (0x00) oder nicht (0xf0)
                  LDA OS_ParseNum+0 STA OS_PtrA+0               ; store flash erase addr in OS_PtrA
                  LDA OS_ParseNum+1 STA OS_PtrA+1
                    CPI >OS_SSDStart BCC OS_ErrorPrompt         ; only allow erasing >= OS_SSDStart
                    CPI 0x80 BCS OS_ErrorPrompt                 ; only allow erasing  < 0x8000
                      JPS FLASH_Erase                           ; block address is in OS_PtrA
                      JPA OS_Prompt
  format_all:     LDI <OS_SSDStart STA OS_PtrA+0                ; start of OS_SSDStart
                  LDI >OS_SSDStart STA OS_PtrA+1
  format_loop:    JPS FLASH_Erase                               ; block address is in OS_PtrA
                  LDI 0x10 ADB OS_PtrA+1 BPL format_loop        ; gehe bis 0x70, bei 0x80 ist Schluss
                    JPA OS_Prompt

; ****************************************************************************************************
; COMMAND 'Save data to SSD file system', usage: s <first hex addr> <last hex addr> <filename> <ENTER>
; ****************************************************************************************************
OS_SaveFile:      INB OS_ParsePtr
                  JPS OS_ParseHexNum                                  ; parse first address
                  LDR OS_ParsePtr CPI 10 BEQ OS_ErrorPrompt           ; wurde zu früh ENTER gedrückt?
                    LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorPrompt        ; wurde eine Zahl eingelesen?
                      LDA OS_ParseNum+1 STA OS_PtrA+1
                      LDA OS_ParseNum+0 STA OS_PtrA+0                 ; first -> PtrA
                  JPS OS_ParseHexNum                                  ; parse last address
                  LDR OS_ParsePtr CPI 10 BEQ OS_ErrorPrompt
                    LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorPrompt
                      LDA OS_ParseNum+1 STA OS_PtrB+1
                      LDA OS_ParseNum+0 STA OS_PtrB+0                 ; last -> PtrB
  sf_searchname:  LDR OS_ParsePtr                                     ; parse for anything but RETURN for valid filename
                  CPI 10 BEQ OS_ErrorPrompt
                  CPI 32 BNE sf_validname                             ; skip leading spaces...
                    INW OS_ParsePtr
                    JPA sf_searchname 
  sf_validname:   LDA OS_ParsePtr+0 PHS LDA OS_ParsePtr+1 PHS         ; push parameters on stack
                  LDA OS_PtrA+0 PHS LDA OS_PtrA+1 PHS
                  LDA OS_PtrB+0 PHS LDA OS_PtrB+1 PHS
                  JPS SSD_SaveFile
                  LDI 5 ADB 0xffff PLS                                ; clean up stack and pull result
                  CPI 0 BEQ OS_ErrorPrompt                            ; check for error
                    JPA OS_Prompt

; *************************************************************
; COMMAND 'Load file from SSD', usage: ... l <filename> <ENTER>
; *************************************************************
OS_LoadFile:        INB OS_ParsePtr
                    CLW OS_ParseNum                                   ; don't use a custom start address here
  lf_searchname:    LDR OS_ParsePtr                                   ; parse for anything but RETURN for valid filename
                    CPI 10 BEQ OS_ErrorPrompt
                    CPI 0 BEQ OS_ErrorPrompt
                    CPI 32 BNE lf_validname                           ; skip leading spaces...
                      INW OS_ParsePtr JPA lf_searchname
  lf_validname:     LDA OS_ParsePtr+0 PHS LDA OS_ParsePtr+1 PHS
                    JPS SSD_LoadFile
                      PLS STA OS_MemAddr+0 PLS STA OS_MemAddr+1 CPI 0x80 BCC OS_ErrorPrompt    ; check if successful
                      JPA OS_Prompt

; **********************************************
; COMMAND 'Show SSD directory', usage: t <ENTER>
; **********************************************
OS_DirTable:      INB OS_ParsePtr
                  LDI <dirtext PHS LDI >dirtext PHS JPS OS_Print PLS PLS          ; print the directory headline
                  LDI <OS_SSDStart STA OS_PtrC+0
                  LDI >OS_SSDStart STA OS_PtrC+1                                  ; look at beginning of SSD area
  dir_file:         LDA OS_PtrC+1 CPI 0x80 BCS dir_showfree                       ; pointer inside FLASH?
                    LDR OS_PtrC CPI 0xff BEQ dir_showfree                         ; end of dir reached
                    LDA OS_PtrC+0 PHS LDA OS_PtrC+1 PHS JPS OS_Print PLS PLS      ; print filename                    
                    LDI <coltext PHS LDI >coltext PHS JPS OS_Print PLS PLS        ; move cursor to absolute column
                    LDI 21 ADW OS_PtrC                                            ; advance over header to start addr MSB!!!
                    LDR OS_PtrC PHS JPS OS_PrintHex PLS
                    DEW OS_PtrC LDR OS_PtrC PHS JPS OS_PrintHex PLS               ; print start addr
                    JPS OS_PrintSpace
                    LDI 3 ADW OS_PtrC                                             ; advance to bysize MSB!!!
                    LDR OS_PtrC STA OS_PtrB+1 PHS JPS OS_PrintHex PLS
                    DEW OS_PtrC LDR OS_PtrC STA OS_PtrB+0 PHS JPS OS_PrintHex PLS
                    JPS OS_PrintEnter
                    LDI 2 ADW OS_PtrC                                             ; advance to start of data block
                    LDA OS_PtrB+1 ADB OS_PtrC+1 LDA OS_PtrB+0 ADW OS_PtrC         ; jump forward to next file
                    JPA dir_file
  dir_showfree:       LDI 0x00 STA OS_PtrB+0 LDI 0x80 STA OS_PtrB+1
                      LDA OS_PtrC+1 SBB OS_PtrB+1 LDA OS_PtrC+0 SBW OS_PtrB
                      LDI <freetext PHS LDI >freetext PHS JPS OS_Print PLS PLS
                      LDA OS_PtrB+1 PHS JPS OS_PrintHex PLS
                      LDA OS_PtrB+0 PHS JPS OS_PrintHex PLS
                      JPS OS_PrintEnter
                      JPA OS_Prompt

; **********************************************************************
; COMMAND 'Erase file from SSD', migrates the stuff above
; uses: OS_InpBuf+20/21: pointer to potential data to keep
;       OS_InpBuf+23:    SSD sector start addr MSB backup
;       OS_InpBuf+24/25: pointer to first free SSD byte PRIOR to erasing
; **********************************************************************
OS_ZapFile:         INB OS_ParsePtr                                               ; move to potential filename start
  zf_searchname:    LDR OS_ParsePtr
                    CPI 0 BEQ OS_ErrorPrompt                                      ; parse for beginning of valid filename
                    CPI 10 BEQ OS_ErrorPrompt
                    CPI 32 BNE zf_validname                                       ; skip over leading spaces
                      INW OS_ParsePtr JPA zf_searchname

  zf_validname:     LDA OS_ParsePtr+0 PHS LDA OS_ParsePtr+1 PHS                   ; push <nameptr>
                    JPS SSD_FindFile                                              ; SUCCESS => PtrA = file pointer
                    PLS STA OS_PtrA+1 PLS STA OS_PtrA+0                           ; pull <fileptr>
                    LDA OS_PtrA+1 CPI 0x80 BCS OS_ErrorPrompt                     ; FAILURE => can't find that file!                             
                      PHS JPS OS_AreYouSure PLS                                   ; FILE FOUND! Now ask for permission.
                      CPI 'y' BNE OS_Prompt
                      PHS PHS JPS SSD_FindFree                                    ; find first free byte
                      PLS STA OS_InpBuf+25 PLS STA OS_InpBuf+24                   ; copy current sector's 'data to keep' from start of sector to OS_PtrA-1 to SSD buffer
                      CLB OS_PtrB+0 LDA OS_PtrA+1                                 ; calculate sector start address in OS_PtrB
                      LSR LSR LSR LSR LSL LSL LSL LSL                             ; clear lower nibble of MSB
                      STA OS_PtrB+1 STA OS_InpBuf+23                              ; store sector start addr in OS_InpBuf+23 too
                      LDI <OS_SSDRAMBuf STA OS_PtrC+0                             ; destination = SSD buffer in RAM
                      LDI >OS_SSDRAMBuf STA OS_PtrC+1                             ; to PtrC

                      ; PtrA: pointer to file to be erased, PtrB: sector start address, PtrC: start of RAM buffer
  e_copyloop1:        LDA OS_PtrB+1 CPA OS_PtrA+1 BCC e_copynext                  ; keep potential rest data below the file to be erased
                        LDA OS_PtrB+0 CPA OS_PtrA+0 BCC e_copynext
                          JPA e_gotokeep                                          ; everything until start of erase data has been copied
  e_copynext:         LDR OS_PtrB STR OS_PtrC                                     ; copy data below file into SSD buffer
                      INW OS_PtrB INW OS_PtrC
                      JPA e_copyloop1
  
  e_gotokeep:         ; PtrA: Start of file to be erased
                      LDI 22 ADW OS_PtrA                                          ; advance over header to bytesize LSB
                      LDR OS_PtrA STA OS_PtrB+0 INW OS_PtrA                       ; extract bytesize -> PtrB
                      LDR OS_PtrA STA OS_PtrB+1 INW OS_PtrA                       ; PtrA after header
                      LDA OS_PtrB+1 ADB OS_PtrA+1 LDA OS_PtrB+0 ADW OS_PtrA       ; add size => PtrA now points beyond file to be erased

                      ; fill up SSD buffer with more data to keep up to existing data, fill rest with 0xff
                      ; PtrA: Start of potential data to keep, PtrC: next free pos in OS_SSDRAMBuf
  e_copyloop2:        LDA OS_PtrC+1 CPI 0xf0 BCS e_blockready                     ; check, if buffer block is ready/full
                        LDA OS_PtrA+1 CPA OS_InpBuf+25 BCC e_copynext2            ; check against existing data
                          LDA OS_PtrA+0 CPA OS_InpBuf+24 BCC e_copynext2
                            LDI 0xff STR OS_PtrC INW OS_PtrC                      ; fill with 0xff
                            JPA e_copyloop2
  e_copynext2:        LDR OS_PtrA STR OS_PtrC                                     ; write data into SSD buffer RAM
                      INW OS_PtrA INW OS_PtrC
                      JPA e_copyloop2

  e_blockready:       ; save PtrA (start of next potential data to keep) in OS_InpBuf+20/21 for later use
                      LDA OS_PtrA+0 STA OS_InpBuf+20
                      LDA OS_PtrA+1 STA OS_InpBuf+21

                      ; erase FLASH block
                      CLB OS_PtrA+0 LDA OS_InpBuf+23 STA OS_PtrA+1                ; PtrA = sector start address to be erased
                      JPS FLASH_Erase

                      ; write data in RAM buffer back to FLASH block
                      LDI <OS_SSDRAMBuf STA OS_PtrA+0                             ; set source
                      LDI >OS_SSDRAMBuf STA OS_PtrA+1
                      LDI 0x00 STA OS_PtrB+0                                      ; set bytesize
                      LDI 0x10 STA OS_PtrB+1
                      CLB OS_PtrC+0 LDA OS_InpBuf+23 STA OS_PtrC+1                ; set destination
                        LDI '.' OUT JPS _WaitUART                                 ; indicate block erase & write progress
                      JPS FLASH_Write
                      LDA OS_PtrB+1 CPI 0xff BNE OS_ErrorPrompt                   ; check error state

                      ; PtrC: points beyond last byte written to SSD
                      LDA OS_PtrC+1 CPA OS_InpBuf+25 BCC e_goon BNE e_alldone     ; wurde bereits über existing data hinaus geschrieben?
                        LDA OS_PtrC+0 CPA OS_InpBuf+24 BCS e_alldone                        
  e_goon:                 ; restore the pointers A and C properly
                          LDI 0x10 ADB OS_InpBuf+23                               ; increment the sector address to write to
                          LDI <OS_SSDRAMBuf STA OS_PtrC+0                         ; PtrC: SSD buffer start in RAM
                          LDI >OS_SSDRAMBuf STA OS_PtrC+1
                          LDA OS_InpBuf+20 STA OS_PtrA+0                          ; PtrA: restore pointer to next data to keep
                          LDA OS_InpBuf+21 STA OS_PtrA+1 
                          JPA e_copyloop2                                         ; process next whole block
  e_alldone:          LDI 10 OUT JPS _WaitUART                                    ; ALLES FERTIG!
                      JPA OS_Prompt

; ************************************************************************
; Eraseses a 4KB FLASH memory block without ANY protection (use with care)
; PtrA: address of FLASH block to be erased to 0xff, PtrA remains unchanged
; only the upper nibble of the MSB is relevant here
; ************************************************************************
FLASH_Erase:      LDI 0xaa STA 0x5555                          ; issue FLASH ERASE COMMAND
                  LDI 0x55 STA 0x2aaa
                  LDI 0x80 STA 0x5555
                  LDI 0xaa STA 0x5555
                  LDI 0x55 STA 0x2aaa
                  LDI 0x30 STR OS_PtrA                         ; initiate the BLOCK ERASE command
  fe_wait:    	  LDR OS_PtrA LSL BCC fe_wait                  ; wait for 8th bit go HIGH, this code HAS to run in RAM!
                    RTS

; ********************************************************
; Loads file <name> from SSD, <name> must be terminated by 0 or ENTER
; push: nameptr_lsb, nameptr_msb
; pull: target_lsb, target_msb
; success: target_msb >= 0x80
; modifies: ParsePtr, PtrA, PtrB, PtrC
; ***********************************************************
SSD_LoadFile:       LDS 4 PHS LDS 4 PHS                                           ; re-push nameptr_lsb/msb
                    JPS SSD_FindFile                                              ; SUCCESS => PtrA = file pointer
                    PLS STA OS_PtrA+1 PLS STA OS_PtrA+0                           ; pull <fileptr>
                    LDA OS_PtrA+1 CPI 0x80 BCS lf_returnfalse                     ; FAILURE => can't find that file! 
                      LDI 20 ADW OS_PtrA                                          ; advance over header to start addr LSB
                      LDR OS_PtrA STA OS_PtrC+0 STS 3 INW OS_PtrA                 ; extract destination -> PtrC and stack
                      LDR OS_PtrA STA OS_PtrC+1 STS 4 INW OS_PtrA        
  lf_extractsize:     LDR OS_PtrA STA OS_PtrB+0 INW OS_PtrA                       ; extract bytesize -> PtrB
                      LDR OS_PtrA STA OS_PtrB+1 INW OS_PtrA                       ; PtrA now holds source address
  lf_loadloop:          DEW OS_PtrB BCC lf_returntrue						                  ; alles kopiert?
                        LDR OS_PtrA STR OS_PtrC								                    ; copy block from A -> to C
                        INW OS_PtrA INW OS_PtrC
                        JPA lf_loadloop
  lf_returnfalse:   LDI 0 STS 4                                                   ; invalidate target_msb
  lf_returntrue:    RTS

; ***************************************************************************************
; Saves memory area as file <name> to SSD drive, checks if there is enough space
; push: nameptr_lsb, nameptr_msb, first_lsb, first_msb, last_lsb, last_msb
; pull: --, --, --, --, --, ret
; success: ret = 1, failure: ret = 0
; modifies: OS_Count, PtrA, PtrB, PtrC, PtrD, OS_InpBuf
; ***************************************************************************************
                  ; assemble a zero-filled 20-byte filename starting at OS_InBuf for the header
SSD_SaveFile:     LDI 19 STA OS_Count                                   ; copy up to 19 chars of filename
                  LDS 8 STA OS_PtrA+0 LDS 7 STA OS_PtrA+1               ; nameptr -> PtrA
                  LDI <OS_InpBuf STA OS_PtrB+0 LDI >OS_InpBuf STA OS_PtrB+1   ; OS_InpBuf -> PtrB
  sf_namecopy:      LDR OS_PtrA                                         ; read a name char
                    CPI 11 BCC sf_nameend                               ; anything <= LF ends name
                    STR OS_PtrB                                         ; copy name char
                    INW OS_PtrA INW OS_PtrB
                    DEB OS_Count BNE sf_namecopy
  sf_nameend:     LDI 0 STR OS_PtrB                                     ; overwrite rest including 20th byte with zero
                  INW OS_PtrB DEB OS_Count BCS sf_nameend

                  ; look for enough free space on the SSD partition
                  PHS PHS JPS SSD_FindFree
                  PLS STA OS_PtrC+1 STA OS_PtrD+1                       ; free -> PtrC, PtrD
                  PLS STA OS_PtrC+0 STA OS_PtrD+0
                  LDS 6 SBW OS_PtrD LDS 5 SBB OS_PtrD+1                 ; free - start -> PtrD
                  LDS 4 STA OS_PtrB+0 ADW OS_PtrD                       ; last -> PtrB
                  LDS 3 STA OS_PtrB+1 ADB OS_PtrD+1                     ; free - start + last -> PtrD
                  LDI 24 ADW OS_PtrD                                    ; free - start + last + 24 -> PtrD
                  LDA OS_PtrD+1 CPI 0x80 BCS sf_returnfalse             ; wurde kein freier Platz gefunden?

                  ; calculate data bytesize
                  LDS 5 SBB OS_PtrB+1 BCC sf_returnfalse                ; last - first -> PtrB
                  LDS 6 SBW OS_PtrB BCC sf_returnfalse
                    INW OS_PtrB                                         ; last - first + 1 -> PtrB

                  ; write header start address and bytesize
                  LDS 6 STA OS_InpBuf+20 LDS 5 STA OS_InpBuf+21         ; write start addr to header
                  LDA OS_PtrB+0 STA OS_InpBuf+22                        ; write bytesize to header
                  LDA OS_PtrB+1 STA OS_InpBuf+23
                  
                  ; write header to FLASH memory
                  LDI <OS_InpBuf STA OS_PtrA+0                        ; start addr of header -> PtrA
                  LDI >OS_InpBuf STA OS_PtrA+1                        ; free addr is already in PtrC
                  CLB OS_PtrB+1 LDI 24 STA OS_PtrB+0                  ; bytesize of header -> PtrB
                  JPS FLASH_Write                                     ; write the header (incrementing OS_PtrC)
                  LDA OS_PtrB+1 CPI 0xff BNE sf_returnfalse           ; check if all bytes have been written successfully

                  ; write body to FLASH memory
                  LDS 6 STA OS_PtrA+0 LDS 5 STA OS_PtrA+1             ; start -> PtrA
                  LDA OS_InpBuf+22 STA OS_PtrB+0                      ; bytesize -> PtrB
                  LDA OS_InpBuf+23 STA OS_PtrB+1                      ; PtrC already positioned behind header
                  JPS FLASH_Write                                     ; write the data body
                  LDA OS_PtrB+1 CPI 0xff BNE sf_returnfalse           ; check if all bytes have been written successfully
                    LDI 1 STS 8 RTS                                   ; return success

  sf_returnfalse: LDI 0 STS 8 RTS                                     ; return failure

; *********************************************************************************
; Writes data to FLASH (but protects RAM), PtrA: source, PtrB: bytesize, PtrC: dest
; push: dest_lsb, dest_msb, bytesize_lsb, bytesize_msb, source_lsb, source_msb
; pull: -, -, -, result, nextdest_msb, nextdest_lsb
; success: result = 0xff
; modifies: PtrB (0xffff: success, else failure)
;           PtrA (points to byte after source data if successful)
;           PtrC (points to byte after target data if successful)
; *********************************************************************************
FLASH_Write:      DEW OS_PtrB BCC fw_return                     ; Anzahl runterzählen (success rückmelden)
                    LDA OS_PtrC+1 CPI 0x80 BCS fw_return        ; teste, ob dest addr < 0x8000 ist (FLASH)
                      LDR OS_PtrC CPI 0xff BNE fw_return        ; teste, ob dest byte == 0xff ist
                        LDI 10 STA OS_Count                     ; re-read a maximum times
                        LDI 0xaa STA 0x5555                     ; INIT FLASH WRITE PROGRAM
                        LDI 0x55 STA 0x2aaa
                        LDI 0xa0 STA 0x5555
                        LDR OS_PtrA STR OS_PtrC									; START WRITE PROCESS
  fw_writecheck:          DEB OS_Count BCC fw_return            ; write took too long => ERROR!
                          LDR OS_PtrA CPR OS_PtrC               ; re-read FLASH location
                          BNE fw_writecheck                     ; data okay?
                        INW OS_PtrA INW OS_PtrC                 ; increase both pointers to next location
                        JPA FLASH_Write
  fw_return:      RTS

; ***********************************************************
; Returns the address <free> of the first free byte in SSD
; push: ---, ---
; pull: free_msb, free_lsb
; success: free_msb < 0x80
; modifies: PtrC, PtrD
; ***********************************************************
SSD_FindFree:     LDI <OS_SSDStart STA OS_PtrC+0
                  LDI >OS_SSDStart STA OS_PtrC+1                      ; look at beginning of SSD area
  ffree_loop:     LDA OS_PtrC+1 CPI 0x80 BCS ffree_return             ; return >=0x8000
                  LDR OS_PtrC CPI 0xff BEQ ffree_return               ; return with free diskspace
                    LDI 22 ADW OS_PtrC                                ; advance over header to bytesize info
                    LDR OS_PtrC STA OS_PtrD+0 INW OS_PtrC             ; read out the bytesize of this file
                    LDR OS_PtrC STA OS_PtrD+1 INW OS_PtrC             ; PtrC now points right after header
                    LDA OS_PtrD+1 ADB OS_PtrC+1                       ; add the bytesize to OS_PtrC
                    LDA OS_PtrD+0 ADW OS_PtrC+0
                    JPA ffree_loop
  ffree_return:   LDA OS_PtrC+0 STS 4 LDA OS_PtrC+1 STS 3             ; put file pointer on stack
                  RTS

; *************************************************
; Searches for <filename> stored at <nameptr>
; <filename> must be terminated with either 0 or LF
; push: nameptr_lsb, nameptr_msb
; pull: fileptr_msb, fileptr_lsb
; success: fileptr_msb < 0x80
; modifies: OS_PtrA, OS_PtrB, OS_PtrC
; *************************************************
SSD_FindFile:     ; browse through all stored files and see if <filename> matches name, any zero stops
                  LDI <OS_SSDStart STA OS_PtrA+0 LDI >OS_SSDStart STA OS_PtrA+1   ; PtrA -> start of SSD area
  ff_search:      LDA OS_PtrA+1 CPI 0x80 BCS ff_returnfalse                       ; end of SSD reached -> no match!
                  LDR OS_PtrA CPI 0xff BEQ ff_returnfalse                         ; end of data reached -> no match!
                    ; check if name matches
                    LDA OS_PtrA+0 STA OS_PtrC+0 LDA OS_PtrA+1 STA OS_PtrC+1       ; copy address of file A -> C
                    LDS 4 STA OS_PtrB+0 LDS 3 STA OS_PtrB+1                       ; copy address of name -> B                    
  match_loop:       LDR OS_PtrB CPI 10 BNE trymatch                               ; tausche ENTER gegen 0 aus
                      LDI 0
  trymatch:         CPR OS_PtrC BNE files_dontmatch                               ; stimmen Buchstaben überein?
                      CPI 0 BEQ ff_returntrue                                     ; wurde gemeinsame 0 erreicht => match!
                        INW OS_PtrB INW OS_PtrC                                   ; sonst gehe zum nächsten
                        JPA match_loop
                    ; ***** these filenames don't match *****
  files_dontmatch:  LDI 22 ADW OS_PtrA                                            ; advance over header to bytesize LSB
                    LDR OS_PtrA STA OS_PtrB+0 INW OS_PtrA                         ; extract bytesize -> PtrB
                    LDR OS_PtrA STA OS_PtrB+1 INW OS_PtrA
                    LDA OS_PtrB+1 ADB OS_PtrA+1 LDA OS_PtrB+0 ADW OS_PtrA         ; PtrA points beyond file
                    JPA ff_search
  ff_returnfalse:     LDI 0x00 STS 4 LDI 0x80 STS 3 RTS                           ; return false file pointer
  ff_returntrue:      LDA OS_PtrA+0 STS 4 LDA OS_PtrA+1 STS 3 RTS                 ; return true file pointer

; *********************************************
; This section contains all text and other data
; *********************************************
  mnemonics:	  'NOP', 'BNK', 'OUT', 'CLC', 'SEC', 'LSL', 'ROL', 'LSR', 'ROR', 'ASR', 'INP', 'NEG', 'INC', 'DEC'
                'LDI', 'ADI', 'SBI', 'CPI', 'ACI', 'SCI'
                'JPA', 'LDA', 'STA', 'ADA', 'SBA', 'CPA', 'ACA', 'SCA'
                'JPR', 'LDR', 'STR', 'ADR', 'SBR', 'CPR', 'ACR', 'SCR'
                'CLB', 'NEB', 'INB', 'DEB', 'ADB', 'SBB', 'ACB', 'SCB'
                'CLW', 'NEW', 'INW', 'DEW', 'ADW', 'SBW', 'ACW', 'SCW'
                'LDS', 'STS', 'PHS', 'PLS', 'JPS', 'RTS'
                'BNE', 'BEQ', 'BCC', 'BCS', 'BPL', 'BMI'
                
  oplength:     0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; operator byte length
                1,1,1,1,1,1
                2,2,2,2,2,2,2,2
                2,2,2,2,2,2,2,2
                2,2,2,2,2,2,2,2
                2,2,2,2,2,2,2,2
                -1,-1,0,0,2,0
                2,2,2,2,2,2
								
  hometxt: 	    27, '[H', 27, '[J', 0
  starttxt:     '| MINIMAL CPU SYSTEM 1.5 by C. Herting |', 10
                '| 32KB RAM 512KB SSD - Type m for menu |', 10, 0
  
  menutxt:      10
                '1[234][ r] Set HEX addr A [run]', 10
                '[A].B      Show RAM [A]..B [q]', 10
                ':C[ D]     Deposit C [D] at A..', 10
                'v A B C    Fill RAM A..B with C', 10
                'k A B C    Copy A..B to C..', 10
                'i A        Disassemble A.. [q]', 10
                'w          Wipe SSD bank', 10
                's A B file Save A..B to SSD file', 10
                'l file     Load file from SSD', 10
                'z file     Zap file from SSD', 10
                't          SSD table of content', 10
                'n A        SSD bank 0..f', 10
                10, 0

  dirtext:      10
                'FILENAME........... DEST SIZE', 10, 0
  coltext:      27, '[21G', 0
  freetext:     27, '[21GFREE ', 0
  suretext:     '[y/n]?', 10, 0

OS_END:                                         ; address of first unused byte after OS code

                #end
#org 0x0000     OS_SSDStart:                    ; Beginning of SSD drive (goes up to 0x7fff in each bank)
#org 0xe000     OS_SSDRAMBuf:                   ; 4KB buffer for 'data to keep' when moving files and erasing SSD blocks                                
                                                ; VARIABLES USED BY THE OS
#org 0xfeb0     OS_MemAddr:                     ; current memory address (16 bytes von MINOS am unteren Ende des Stack)
#org 0xfeb2     OS_ParsePtr:                    ; Zeiger auf das letzte eingelesene Zeichen (to be reset at startup)
#org 0xfeb4     OS_ParseNum:                    ; 3-byte storage for a parsed 16-bit number, MSB: f0=invalid, 0=valid
#org 0xfeb7     OS_Mode:                        ; byte 0: normal, 1: deposit, 2: list
#org 0xfeb8     OS_Count:                       ; lokaler byte counter
#org 0xfeb9     OS_PtrA:                        ; lokaler pointer
#org 0xfebb     OS_PtrB:                        ; lokaler pointer, Zeiger auf mnemonic input position
#org 0xfebd     OS_PtrC:                        ; lokaler pointer, reuse as byte line counter & 3-byte-Speicher für mnemonic
#org 0xfec0     OS_PtrD:                        ; lokaler pointer
                                                ; ... free space for more variables
#org 0xfec9     OS_InpBuf:                      ; '55 bytes line input string (also used by FLASH erase monitor)

; -------------------------------------------------------------------------------
; Copyright (c) 2021 Carsten Herting (slu4)
; -------------------------------------------------------------------------------
; MIT LICENSE
; Permission is hereby granted, free of charge, to any person obtaining a copy of
; this software and associated  documentation files  (the "Software"), to deal in
; the Software without  restriction, including  without  limitation the rights to
; use, copy,  modify, merge, publish, distribute, sublicense,  and/or sell copies
; of the Software, and  to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
; The above copyright notice and  this permission notice shall be included in all
; copies or substantial portions of the Software.
; THE  SOFTWARE  IS PROVIDED "AS IS",  WITHOUT  WARRANTY OF  ANY KIND, EXPRESS OR
; IMPLIED,  INCLUDING  BUT  NOT  LIMITED  TO  THE  WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR  A PARTICULAR  PURPOSE AND  NONINFRINGEMENT. IN NO  EVENT SHALL THE
; AUTHORS  OR  COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM, DAMAGES  OR  OTHER
; LIABILITY,  WHETHER IN AN ACTION  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN  CONNECTION WITH  THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.
; -------------------------------------------------------------------------------
