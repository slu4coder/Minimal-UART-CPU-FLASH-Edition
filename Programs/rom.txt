; MinOS 1.5 for the 8-Bit Minimal Computer System (FLASH Edition)
; written by Carsten Herting - last update Apr 14th 2021

; USAGE for In-situ programming of OS: Open command shell,
; type asm rom.txt , copy & paste date via terminal to
; $e000-$efff, load prom, type 8000 r, enjoy new OS.

; *********************************
; Create a file header for OS image
; *********************************
								0                                              ; = NOP, creates a non-deletable invalid filename...               
								JPA OS_Copier                                  ; ... and jumps to OS copier routine
                $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff         ; rest of the filename can
                $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff         ; be filled with anything
                $f000                                          ; start address: value not important
                $0fe8                                          ; byte size: reserves first 4KB for OS image

; ****************************
; Copies the OS image to $f000 
; ****************************
OS_Copier:      LDI <OS_Image STA OS_PtrA+0                    ; OS source address
                LDI >OS_Image STA OS_PtrA+1
                LDI <$f000 STA OS_PtrB+0                       ; OS target address
                LDI >$f000 STA OS_PtrB+1
  copyos:       LDR OS_PtrA STR OS_PtrB                        ; copy the OS code to it's RAM area
                INW OS_PtrA INW OS_PtrB                        ; uses OS pointer variables for this
                CPI $ff BNE copyos                             ; copy ends with memory location $feff
                  JPA $f000                                    ; start the OS

; ************************
;
; START OF THE MINOS IMAGE
;
; ************************
OS_Image:

; ******************************
; Memory Monitor core aka WOZMON
; ******************************
  #end          
  *=$f000       																							 ; assemble with this destination address
  #begin
                LDI <OS_TopOfStack STA OS_StackPointer         ; don't change first 10 bytes: 'prom.txt' relies on it
                LDI <welcometxt STS -3 LDI >welcometxt STS -4
                JPS OS_PrintText
  OS_LineStart:	LDA OS_MemAddr+1 STS -3 JPS OS_PrintHexByte    ; schreibe die aktuelle examine-Adresse
                LDA OS_MemAddr+0 STS -3 JPS OS_PrintHexByte
                JPS OS_PrintSpace
                JPS OS_ReadLine                     ; get a line of input until ENTER or end of string is hit
                JPS preset                          ; reset parsing variables and pointers
                CLB OS_Mode                         ; start with monitor mode = 0					
  parsing:      LDR OS_ParsePtr                     ; ***** BYTE-BY-BYTE PARSING OF THE LINE INPUT *****
                CPI 'l' BEQ OS_LoadFile             ; COMMANDS
                CPI 's' BEQ OS_SaveFile
                CPI 'z' BEQ OS_ZapFile
                CPI 't' BEQ OS_DirTable
                CPI 'w' BEQ OS_WipeSSD
                CPI 'i' BEQ OS_Disasm
                CPI 'v' BEQ OS_HexFill
                CPI 'k' BEQ OS_HexCopy
                CPI 'n' BEQ OS_Bank
                CPI 'm' BEQ OS_Menu
                CPI 'r' BEQ OS_Run
                CPI ':' BEQ doppel                  ; : switch to 'deposit' mode
                CPI '.' BEQ punkt                   ; . switch to 'list' mode                    
						    CPI 'a' BCS sletter                 ; a..f for hex numbers
                CPI 'A' BCS bletter		              ; A..Z for letters
                CPI '0' BCS zahl                    ; 0..9 for numbers
	                LDA OS_ParseNum+2                 ; interpretiere Zeichen als GO! according to mode (hier ' ' oder ENTER)
                  CPI 0 BEQ validdata               ; prüfe, ob überhaupt valide parse-Daten vorliegen
    								LDA OS_PtrB+0           				; KEINE VALIDEN DATEN!
		    						CPI <OS_PtrC           				  ; prüfe ob ein unvollständiger mnemonic vorliegt
				    				BEQ nohalfinp
						    			JPS OS_PrintError        			; schreibe ? für mnemonic-Fehler
	nohalfinp:          JPA clrparsed
  OS_Menu:      LDI <menutxt STS -3 LDI >menutxt STS -4 JPS
                OS_PrintText
                JPA OS_LineStart
  OS_Run:				INB OS_ParsePtr
                JPR OS_MemAddr                      ; r => jumps immediately to OS_MemAddr
  doppel:       LDI 1 JPA setmode                   ; : => umschalten auf DEPOSIT OS_Mode=1
  punkt:          LDI 2                             ; . => umschalten auf LIST OS_Mode
	  setmode:	  STA OS_Mode
                LDA OS_ParseNum+2                   ; validen input vorhergehend . oder : als 'OS_MemAddr' übernehmen
                CPI 0 BNE clrparsed                 ; liegt valider input vor?
    setmemadr:    LDA OS_ParseNum STA OS_MemAddr    ; validen Daten -> OS_MemAddr
                  LDA OS_ParseNum+1 STA OS_MemAddr+1
                  JPA clrparsed									    ; . : kam ohne valide Addresse davor
  bletter:      STR OS_PtrB                         ; Gross-Zeichen X speichern
                LDI $f0 STA OS_ParseNum+2           ; jede Eingabe X entwertet OS_ParseNum, da Teil einer ungeprüften Instr.
                INB OS_PtrB+0
                CPI <OS_PtrD                        ; Ende erreicht? (<OS_PtrC + 3 geht leider nicht)
                BCC parsed                          ; noch nicht -> erstmal ist alles getan
                  CLW OS_ParseNum                   ; XXX input vorhanden, opcode-Zähler rücksetzen
                  LDI <OS_PtrC STA OS_PtrB+0        ; set OS_PtrB schon wieder auf Empfang
  fitsuchen:      LDI <mnemonics STA OS_PtrB+0      ; pointer to start of table
                  LDI >mnemonics STA OS_PtrB+1
                  LDA OS_ParseNum ADW OS_PtrB
                  LDA OS_ParseNum ADW OS_PtrB
                  LDA OS_ParseNum ADW OS_PtrB
                  LDA OS_PtrC+0                     ; Abgleich 1. letter
                  CPR OS_PtrB
                  BNE opnotfit
                    INW OS_PtrB
                    LDA OS_PtrC+1                   ; Abgleich 2. letter
                    CPR OS_PtrB
                    BNE opnotfit
                      INW OS_PtrB
                      LDA OS_PtrC+2                 ; Abgleich 3. letter
                      CPR OS_PtrB
                      BEQ opfits
    opnotfit:           INB OS_ParseNum             ; teste nächsten mnemonic
                        CPI 64                      ; alle opcodes durchgeschaut?
                        BCC fitsuchen
                          JPS OS_PrintError
                          JPA clrparsed             ; opcode war nicht dabei -> parse-Daten verwerfen
    opfits:       CLB OS_ParseNum+2                 ; validate parsed number by hand
                  JPA parsed
    sletter:    SBI 39                              ; parse one byte normal hex input
    zahl:       SBI 48
                PHS
                LDI 4 STA OS_Count                  ; shift existing hex data to the left
    shiftloop:    LDA OS_ParseNum+0 LSL STA OS_ParseNum+0
                  LDA OS_ParseNum+1 ROL STA OS_ParseNum+1
                  LDA OS_ParseNum+2 ROL STA OS_ParseNum+2   ; this automatically validates a parsed number
                DEB OS_Count
                BNE shiftloop
                  PLS ADB OS_ParseNum               ; add new hex nibble to the right
                  JPA parsed
    clrparsed:  JPS preset                          ; ***** ENDE DES PARSINGS (AUCH MEHRERER BYTES) *****
    parsed:     LDR OS_ParsePtr                     ; ENDE DES PARSINGS EINES BYTES
                CPI 10                              ; prüfe hier NOCHMAL auf ENTER wg. Zeilenende
                BEQ OS_LineStart                    ; Zeilenende -> warten auf eine neue Zeile
                  INB OS_ParsePtr                   ; gehe zum nächsten Zeichen des Puffers
                  BMI OS_ErrorStart                 ; Zeile zu lang? -> ERROR
                    JPA parsing                     ; nächstes byte aus input parsen
    preset:     CLW OS_ParseNum                     ; clear parsed number
                LDI $f0 STA OS_ParseNum+2           ; invalidate parsed number
                LDI <OS_PtrC STA OS_PtrB+0          ; reset pointer to start of mnemonic input string
                LDI >OS_PtrC STA OS_PtrB+1
                RTS
  validdata:      LDA OS_Mode                       ; ***** ES LIEGT EIN VALIDES PARSE-DATUM VOR *****
                  DEC
                  BCC setmemadr                     ; OS_Mode=0 -> übernimm Daten als einfache neue OS_MemAddr
                  BEQ mode_deposit                  ; OS_Mode=1 -> übernimm Daten als 'deposit'
  mode_list:      LDA OS_MemAddr+0 STA OS_PtrA+0    ; OS_Mode=2 -> Daten sind "list until", print list
                  LDA OS_MemAddr+1 STA OS_PtrA+1    ; kopiere OS_MemAddr zum Benutzen
  startlistpage:  LDI 24 STA OS_PtrC                ; reuse as line counter
  startlistline:  LDI 8 STA OS_Count                ; init: 8 bytes pro Zeile
                  LDA OS_PtrA+1 STS -3 JPS OS_PrintHexByte  ; Drucke aktuelle list-Adresse
                  LDA OS_PtrA+0 STS -3 JPS OS_PrintHexByte
                  JPS OS_PrintSpace
  nextlist:       LDR OS_PtrA STS -3
                  JPS OS_PrintHexByte               ; Speicherinhalt drucken
                  JPS OS_PrintSpace
                  LDA OS_PtrA+0
                  CPA OS_ParseNum+0
                  BNE listweiter
                    LDA OS_PtrA+1
                    CPA OS_ParseNum+1
                    BNE listweiter  
                      JPS OS_PrintEnter                ; die Liste wurde vollständig gedruckt
                      JPA clrparsed
  listweiter:     INW OS_PtrA
                  DEB OS_Count
                  BNE nextlist
                    JPS OS_PrintEnter
                    DEB OS_PtrC                     ; reuse as line counter
                    BNE startlistline
  listreadchar:       INP BEQ listreadchar
                      CPI 'q' BNE startlistpage     ; warte auf Tastendruck
                      JPA clrparsed
  mode_deposit: LDA OS_ParseNum                     ; validen Daten -> deposit
                STR OS_MemAddr
                INW OS_MemAddr                          
                JPA clrparsed

; ************************************************************************************************************************

; *******************
; Helpful subroutines
; *******************
OS_PrintSpace:      LDI ' ' JPA printchar
  OS_PrintError:    LDI '?' OUT JPS OS_WaitUART
  OS_PrintEnter:    LDI 10
    printchar:      OUT JPS OS_WaitUART
                    RTS

  OS_ErrorStart:    JPS OS_PrintError               ; display error '?' and goto WOZMON newline input
                    JPA OS_LineStart

  OS_ReturnFalse:		LDI 0 STS 0 RTS												; signal FAILURE
								
  OS_ReturnTrue:		LDI 1 STS 0 RTS												; signal SUCCESS

  OS_AreYouSure:    LDI <suretext STS -3
                    LDI >suretext STS -4
                    JPS OS_PrintText
    ayswait:        INP BEQ ayswait
                    CPI 'y' BNE OS_ReturnFalse
                      JPA OS_ReturnTrue

; ********************************************************************************************
; Reading in keyboard input into OS_InpBuf until [ENTER] or end of string is hit
; ********************************************************************************************
OS_ReadLine:  JPS readexit                          ; resets the LSB of OS_ParsePtr
  readchar:   INP BEQ readchar                      ; FAST testing (reading/clearing must happen within 616 cycles of receiving)
              OUT                                   ; 4 output without waiting, since the maximum receive rate is 115.2kHz anyway
              STR OS_ParsePtr                       ; 10
              CPI 10 BEQ readexit                   ; 10 teste auf ENTER & BACKSPACE
              BCS nobackspace                       ; 6(5) ... backspace wäre "8"
                DEB OS_ParsePtr                     ; 10 BACKSPACE war's
                CPI <OS_InpBuf                      ; 5
                BCS readchar                        ; 6(5)
                  NOP NOP NOP NOP NOP NOP NOP       ; 112
                  LDI 32 OUT                        ; 8 backspace kompensieren (siehe auch nä. Zeile), JPS OS_WaitUART ist nicht nötig
  nobackspace:  INB OS_ParsePtr                     ; 10 kompensiert auch den line pointer
                BPL readchar                        ; 6(5) maximale Anzahl von Zeichen wurde eingelesen
  readexit:       LDI >OS_InpBuf STA OS_ParsePtr+1  ; 12 reset the line pointer
                  LDI <OS_InpBuf STA OS_ParsePtr+0  ; 12                 
                  NOP NOP NOP NOP NOP NOP           ; 96
                  RTS                               ; 14

; ********************************************************************************************
; Parses hex number $0-$ffff from OS_ParsePtr into OS_ParseNum
; A valid number was parsed if OS_ParseNum+2 contains $00, otherwise $f0
; ********************************************************************************************
OS_ParseHexNum: CLW OS_ParseNum+0
                JPS pninvalidate
  pnreadchar:   LDR OS_ParsePtr                 ; input string lesen
                CPI 10 BEQ pnreturn             ; ENTER? -> immer zurück (wenn noch nichts da mit Fehler)
                CPI 'g' BCS pninvalidate        ; above f? -> melde Fehler!
                CPI 'a' BCS pnletter            ; a...f?
                CPI ':' BCS pnnotnum            ; above 9? -> Separator: Zurück, wenn was da ist, sonst übergehen.
                CPI '0' BCS pnzahl              ; 0...9?
                  JPA pnnotnum                  ; unter 0? -> Separator: Zurück, wenn was da ist, sonst übergehen.
  pnletter:     SBI 39                          ; parse one byte normal hex input, a = 10
  pnzahl:       SBI 48
                STS 0                           ; gelesenen Wert zwischenspeichern
                LDI 4 STA OS_Count              ; shift existing hex data 4 steps to the left
  pnshiftloop:  LDA OS_ParseNum+0 LSL STA OS_ParseNum+0
                LDA OS_ParseNum+1 ROL STA OS_ParseNum+1
                LDA OS_ParseNum+2 ROL STA OS_ParseNum+2
                DEB OS_Count BNE pnshiftloop
                  LDS 0 ADB OS_ParseNum+0       ; add new hex nibble (carry cannot happen)
                  JPA pnnext
  pnnotnum:     LDA OS_ParseNum+2               ; haben wir noch nix?
                CPI $f0 BNE pnreturn            ; dann weitermachen, sonst zurück mit Wert
  pnnext:         INB OS_ParsePtr               ; move along the input string
                  BCC pnreadchar                ; read more if string end was NOT reached
  pninvalidate: LDI $f0 STA OS_ParseNum+2       ; place "not successful" in upper nibble (will be shifted during parsing)
  pnreturn:     RTS
  
; ********************************************************************************************							
; Schreibt einen nullterminierten String, modifies PtrD
; ********************************************************************************************							
OS_PrintText: LDS -1 STA OS_PtrD+0
            	LDS -2 STA OS_PtrD+1 	         	  ; get LSB and MSB
  printloop:  LDR OS_PtrD CPI 0	    	          ; 15 Print routine
							BEQ printend          		        ; 5(6) string zuende?
            	  OUT NOP NOP NOP NOP NOP NOP NOP NOP ; 132
        		    INW OS_PtrD         		        ; 12 zeige auf das nächste Zeichen
     		        JPA printloop                   ; 6
  printend:	  RTS

; ********************************************************************************************							
; Subroutine printing out a byte as an 8-bit hex value (ATTENTION: It mustn't use subroutine calls!)
; ********************************************************************************************							
OS_PrintHexByte: 	LDS -1                          ; caller deposits value on stack with STS -3
                  LSR LSR LSR LSR								
                  ADI '0'
                  CPI 58
                  BCC Hex8msn
                    ADI 39                        ; mache einen Buchstaben draus
  Hex8msn:				OUT NOP NOP NOP NOP             ; min. 160 cycles bis zum nächsten UART send
                  LDS -1
                  LSL LSL LSL LSL
                  LSR LSR LSR LSR
                  ADI '0'
                  CPI 58
                  BCC Hex8lsn
                    ADI 39
  Hex8lsn:				OUT NOP NOP NOP NOP NOP NOP NOP NOP NOP   ; min 160 cycles (optimized)
                  RTS

; ********************************************************************************************************							
; Waits for a UART transmission to complete, Ziel: min. 160 cycles (8*16 + 30 + 4 = 162 inkl. calling OUT)
; ********************************************************************************************************	
OS_WaitUART:    NOP NOP NOP NOP NOP NOP NOP NOP
                RTS

; ***************************************************************
; COMMAND "Memory filler", copies byte value into block of memory
; ***************************************************************
OS_HexFill:   INB OS_ParsePtr
              JPS OS_ParseHexNum
              LDR OS_ParsePtr CPI 10 BEQ OS_ErrorStart               ; wurde zu früh ENTER gedrückt?
              LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorStart             ; wurde eine Zahl eingelesen?
                LDA OS_ParseNum+1 STA OS_PtrA+1 LDA OS_ParseNum+0 STA OS_PtrA+0 ; copy "from"
                JPS OS_ParseHexNum
                LDR OS_ParsePtr CPI 10 BEQ OS_ErrorStart             ; Test wie oben
                LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorStart
                  LDA OS_ParseNum+1 STA OS_PtrB+1 LDA OS_ParseNum+0 STA OS_PtrB+0    ; copy "to"
                  JPS OS_ParseHexNum
                  LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorStart         ; Test wie oben
  mfnext:           LDA OS_ParseNum+0 STR OS_PtrA             ; BESCHREIBE DEN SPEICHER
                    LDA OS_PtrA+0
                    CPA OS_PtrB+0
                    BNE mfweiter
                      LDA OS_PtrA+1
                      CPA OS_PtrB+1
                      BEQ OS_LineStart
  mfweiter:             INW OS_PtrA
                        JPA mfnext
           
; ***************************************
; COMMAND "Memory block copy A..B -> C.."
; ***************************************
OS_HexCopy:   INB OS_ParsePtr
              JPS OS_ParseHexNum
              LDR OS_ParsePtr CPI 10 BEQ OS_ErrorStart               ; wurde zu früh ENTER gedrückt?
                LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorStart           ; wurde eine Zahl eingelesen?
                  LDA OS_ParseNum+1 STA OS_PtrA+1 LDA OS_ParseNum+0 STA OS_PtrA+0    ; copy source first -> A
              JPS OS_ParseHexNum
              LDR OS_ParsePtr CPI 10 BEQ OS_ErrorStart             ; Test wie oben
                LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorStart
                  LDA OS_ParseNum+1 STA OS_PtrB+1 LDA OS_ParseNum+0 STA OS_PtrB+0    ; copy source last -> B
                  JPS OS_ParseHexNum
                  LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorStart       ; Test wie oben
                  LDA OS_ParseNum+1 STA OS_PtrC+1 LDA OS_ParseNum+0 STA OS_PtrC+0    ; copy destination -> C                
  mcnext:           LDR OS_PtrA STR OS_PtrC									; copy from -> to
										LDA OS_PtrB+0 CPA OS_PtrA+0
                    BNE mcweiter
                      LDA OS_PtrB+1 CPA OS_PtrA+1
                      BEQ OS_LineStart														; Zeige okay
  mcweiter:             INW OS_PtrA INW OS_PtrC
												JPA mcnext

; **********************
; COMMAND "Disassembler"
; **********************
OS_Disasm:    INB OS_ParsePtr
              JPS OS_ParseHexNum
              LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorStart             ; wurde eine Zahl eingelesen?
                LDA OS_ParseNum+1 STA OS_PtrA+1 LDA OS_ParseNum+0 STA OS_PtrA+0 ; copy "start"                
  disstartpage: LDI 24 STA OS_Count
  disnextline:  LDA OS_PtrA+1 STS -3 JPS OS_PrintHexByte            ; Drucke aktuelle list-Adresse
                LDA OS_PtrA+0 STS -3 JPS OS_PrintHexByte
                JPS OS_PrintSpace
                LDI <mnemonics STA OS_PtrB+0 LDI >mnemonics STA OS_PtrB+1   ; point OS_PtrB to lookup
                LDR OS_PtrA
                CPI $40
                BCC disinstruct
                  LDI '?' OUT JPS OS_WaitUART
                  JPA finishline
  disinstruct:  LSL ADR OS_PtrA ADW OS_PtrB                     ; PRINT INSTRUCTION
                LDR OS_PtrB OUT JPS OS_WaitUART INB OS_PtrB+0   ; output the XXX mnemonic
                LDR OS_PtrB OUT JPS OS_WaitUART INB OS_PtrB+0
                LDR OS_PtrB OUT JPS OS_WaitUART
                JPS OS_PrintSpace
                LDI <oplength STA OS_PtrB+0 LDI >oplength STA OS_PtrB+1   ; point OS_PtrB to lookup
                LDR OS_PtrA ADW OS_PtrB
                LDR OS_PtrB                              ; retrieve length of operand
                CPI 0 BEQ finishline
                CPI -1 BEQ disminus
                CPI 1 BEQ disone
  distwo:         LDI 2 ADW OS_PtrA
                  LDR OS_PtrA STS -3 JPS OS_PrintHexByte
                  DEW OS_PtrA
                  LDR OS_PtrA STS -3 JPS OS_PrintHexByte
                  INW OS_PtrA
                  JPA finishline
  disminus:       INW OS_PtrA
                  LDI '-' OUT JPS OS_WaitUART
                  LDR OS_PtrA NEG STS -3 JPS OS_PrintHexByte
                  JPS finishline  
  disone:         INW OS_PtrA
                  LDR OS_PtrA STS -3 JPS OS_PrintHexByte
  finishline:   INW OS_PtrA
                JPS OS_PrintEnter
                DEB OS_Count
                BNE disnextline
  disreadchar:    INP BEQ disreadchar
                  CPI 'q' BNE disstartpage       ; warte auf Tastendruck
                  JPA OS_LineStart

; ***********************************************
; COMMAND "Format" (or SSD Format 4KB Block only)
; ***********************************************
OS_Bank:      INB OS_ParsePtr
              JPS OS_ParseHexNum                              ; parse the input line
              LDA OS_ParseNum+2 CPI $f0 BEQ OS_ErrorStart     ; wurde eine Zahl eingelesen ($00) oder nicht ($f0)
                LDA OS_ParseNum+0 CPI $10 BCS OS_ErrorStart
                BNK
                JPA OS_LineStart

; ***********************************************
; COMMAND "Format" (or SSD Format 4KB Block only)
; ***********************************************
OS_WipeSSD:   JPS OS_AreYouSure
              LDS -2 CPI 0 BEQ OS_LineStart
                INB OS_ParsePtr
                JPS OS_ParseHexNum                              ; parse the input line
                LDA OS_ParseNum+2 CPI $f0 BEQ format_all        ; wurde eine Zahl eingelesen ($00) oder nicht ($f0)
                  LDA OS_ParseNum+0 STA OS_PtrA+0               ; store flash erase addr in OS_PtrA
                  LDA OS_ParseNum+1 STA OS_PtrA+1
                    CPI >OS_SSDStart BCC OS_ErrorStart          ; only allow erasing >= OS_SSDStart
                    CPI $80 BCS OS_ErrorStart                   ; only allow erasing  < $8000
                      JPS FLASH_Erase                           ; block address is in OS_PtrA
                      JPA OS_LineStart
  format_all:     LDI <OS_SSDStart STA OS_PtrA+0                ; start of OS_SSDStart
                  LDI >OS_SSDStart STA OS_PtrA+1
  format_loop:    JPS FLASH_Erase                               ; block address is in OS_PtrA
                  LDI $10 ADB OS_PtrA+1 BPL format_loop         ; gehe bis $70, bei $80 ist Schluss
                    JPA OS_LineStart

; ***********************************************************************************************
; COMMAND "Save data to SSD file system", usage: r <first hex addr> <last hex addr> <name><ENTER>
; ***********************************************************************************************
OS_SaveFile:      INB OS_ParsePtr
                  JPS OS_ParseHexNum                                  ; parse first address
                  LDR OS_ParsePtr CPI 10 BEQ OS_ErrorStart            ; wurde zu früh ENTER gedrückt?
                    LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorStart         ; wurde eine Zahl eingelesen?
                      LDA OS_ParseNum+1 STA OS_PtrA+1
                      LDA OS_ParseNum+0 STA OS_PtrA+0                 ; copy source first -> A
                  JPS OS_ParseHexNum                                  ; parse last address
                  LDR OS_ParsePtr CPI 10 BEQ OS_ErrorStart
                    LDA OS_ParseNum+2 CPI 0 BNE OS_ErrorStart
                      LDA OS_ParseNum+1 STA OS_PtrB+1
                      LDA OS_ParseNum+0 STA OS_PtrB+0                 ; copy source last -> B
  sf_searchname:  LDR OS_ParsePtr
                  CPI 10 BEQ OS_ErrorStart                            ; parse for anything but RETURN
                  CPI 32 BNE sf_foundname                             ; ignore leading spaces
                    INW OS_ParsePtr
                    JPA sf_searchname 
  sf_foundname:   JPS SSD_FindFree                                    ; ParsePtr valid, PtrA, PtrB, hold first and last adr
                  LDA OS_PtrC+1 CPI $80 BCS OS_ErrorStart             ; wurde garkein freier Platz gefunden?
                    JPS SSD_SaveFile
                    LDS -2 CPI 0 BEQ OS_ErrorStart
                      JPA OS_LineStart

; *************************************************************
; COMMAND "Load file from SSD", usage: ... r <filename> <ENTER>
; *************************************************************
OS_LoadFile:        INB OS_ParsePtr
                    CLW OS_ParseNum                             ; don't use a custom start address
                    JPS SSD_LoadFile
                      LDS -2 CPI 0 BEQ OS_ErrorStart              ; check if successful
                      JPA OS_LineStart

; ****************************
; COMMAND "Show SSD directory"
; ****************************
OS_DirTable:      INB OS_ParsePtr
                  LDI <dirtext STS -3 LDI >dirtext STS -4 JPS OS_PrintText        ; print the directory headline
                  LDI <OS_SSDStart STA OS_PtrC+0
                  LDI >OS_SSDStart STA OS_PtrC+1                                  ; look at beginning of SSD area
  dir_file:         LDR OS_PtrC CPI $ff BEQ dir_showfree                          ; end of dir reached
                    LDA OS_PtrC+0 STS -3 LDA OS_PtrC+1 STS -4 JPS OS_PrintText    ; print filename                    
                    LDI <coltext STS -3 LDI >coltext STS -4 JPS OS_PrintText      ; move cursor to absolute column
                    LDI 21 ADW OS_PtrC                                            ; advance over header to start addr MSB!!!
                    LDR OS_PtrC STS -3 JPS OS_PrintHexByte
                    DEW OS_PtrC LDR OS_PtrC STS -3 JPS OS_PrintHexByte            ; print start addr
                    JPS OS_PrintSpace
                    LDI 3 ADW OS_PtrC                                             ; advance to bysize MSB!!!
                    LDR OS_PtrC STA OS_PtrB+1 STS -3 JPS OS_PrintHexByte
                    DEW OS_PtrC LDR OS_PtrC STA OS_PtrB+0 STS -3 JPS OS_PrintHexByte
                    JPS OS_PrintEnter
                    LDI 2 ADW OS_PtrC                                             ; advance to start of data block
                    LDA OS_PtrB+1 ADB OS_PtrC+1 LDA OS_PtrB+0 ADW OS_PtrC         ; jump forward to next file
                    JPA dir_file
  dir_showfree:       LDI <$8000 STA OS_PtrB+0 LDI >$8000 STA OS_PtrB+1
                      LDA OS_PtrC+1 SBB OS_PtrB+1 LDA OS_PtrC+0 SBW OS_PtrB
                      LDI <freetext STS -3 LDI >freetext STS -4 JPS OS_PrintText
                      LDA OS_PtrB+1 STS -3 JPS OS_PrintHexByte
                      LDA OS_PtrB+0 STS -3 JPS OS_PrintHexByte
                      JPS OS_PrintEnter
                      JPA OS_LineStart

; **********************************************************************
; COMMAND "Erase file from SSD", migrates the stuff above
; uses: OS_InpBuf+20/21: pointer to potential data to keep
;       OS_InpBuf+23:    SSD sector start addr MSB backup
;       OS_InpBuf+24/25: pointer to first free SSD byte PRIOR to erasing
; **********************************************************************
OS_ZapFile:         INB OS_ParsePtr                                               ; move to potential filename start

                    JPS SSD_FindFile                                              ; SUCCESS => PtrA = file pointer
                    LDS -2 CPI 0 BEQ OS_ErrorStart                                ; FAILURE => can't find that file!
                      JPS OS_AreYouSure                                           ; file found, now ask for permission
                      LDS -2 CPI 0 BEQ OS_LineStart

                      JPS SSD_FindFree                                            ; returns PtrC, doesn't mess with PtrA
                      LDA OS_PtrC+0 STA OS_InpBuf+24                              ; Reaching 1st free byte => end copy!
                      LDA OS_PtrC+1 STA OS_InpBuf+25                              ; store the address of the 1st free
                      
                      ; copy current sector's "data to keep" from start of sector to OS_PtrA-1 to SSD buffer                  
                      CLB OS_PtrB+0 LDA OS_PtrA+1                                 ; calculate sector start address in OS_PtrB
                      LSR LSR LSR LSR LSL LSL LSL LSL                             ; clear lower nibble of MSB
                      STA OS_PtrB+1 STA OS_InpBuf+23                              ; store sector start addr in OS_InpBuf+23 too
                      LDI <OS_SSDRAMBuf STA OS_PtrC+0                             ; destination = SSD buffer in RAM
                      LDI >OS_SSDRAMBuf STA OS_PtrC+1                             ; to PtrC

                      ; PtrA: pointer to file to be erased, PtrB: sector start address, PtrC: start of RAM buffer
  e_copyloop1:        LDA OS_PtrB+1 CPA OS_PtrA+1 BCC e_copynext                  ; keep potential rest data below the file to be erased
                        LDA OS_PtrB+0 CPA OS_PtrA+0 BCC e_copynext
                          JPA e_gotokeep                                          ; everything until start of erase data has been copied
  e_copynext:         LDR OS_PtrB STR OS_PtrC                                     ; copy data below file into SSD buffer
                      INW OS_PtrB INW OS_PtrC
                      JPA e_copyloop1
  
  e_gotokeep:         ; PtrA: Start of file to be erased
                      LDI 22 ADW OS_PtrA                                          ; advance over header to bytesize LSB
                      LDR OS_PtrA STA OS_PtrB+0 INW OS_PtrA                       ; extract bytesize -> PtrB
                      LDR OS_PtrA STA OS_PtrB+1 INW OS_PtrA                       ; PtrA after header
                      LDA OS_PtrB+1 ADB OS_PtrA+1 LDA OS_PtrB+0 ADW OS_PtrA       ; add size => PtrA now points beyond file to be erased

                      ; fill up SSD buffer with more data to keep up to existing data, fill rest with $ff
                      ; PtrA: Start of potential data to keep, PtrC: next free pos in OS_SSDRAMBuf
  e_copyloop2:        LDA OS_PtrC+1 CPI $f0 BCS e_blockready                      ; check, if buffer block is ready/full
                        LDA OS_PtrA+1 CPA OS_InpBuf+25 BCC e_copynext2            ; check against existing data
                          LDA OS_PtrA+0 CPA OS_InpBuf+24 BCC e_copynext2
                            LDI $ff STR OS_PtrC INW OS_PtrC                       ; fill with $ff
                            JPA e_copyloop2
  e_copynext2:        LDR OS_PtrA STR OS_PtrC                                     ; write data into SSD buffer RAM
                      INW OS_PtrA INW OS_PtrC
                      JPA e_copyloop2

                      ; -----------------------------------------------------
  e_blockready:       ; save PtrA (start of next potential data to keep) in OS_InpBuf+20/21 for later use
                      LDA OS_PtrA+0 STA OS_InpBuf+20
                      LDA OS_PtrA+1 STA OS_InpBuf+21

                      ; erase FLASH block
                      CLB OS_PtrA+0 LDA OS_InpBuf+23 STA OS_PtrA+1                ; PtrA = sector start address to be erased
                      JPS FLASH_Erase

                      ; write data in RAM buffer back to FLASH block
                      LDI <OS_SSDRAMBuf STA OS_PtrA+0                             ; set source
                      LDI >OS_SSDRAMBuf STA OS_PtrA+1
                      LDI <$1000 STA OS_PtrB+0                                    ; set bytesize
                      LDI >$1000 STA OS_PtrB+1
                      CLB OS_PtrC+0 LDA OS_InpBuf+23 STA OS_PtrC+1                ; set destination
                        LDI '.' OUT JPS OS_WaitUART                               ; indicate block erase & write progress
                      JPS SSD_Write
                      LDA OS_PtrB+1 CPI $ff BNE OS_ErrorStart                     ; check error state

                      ; PtrC: points beyond last byte written to SSD
                      LDA OS_PtrC+1 CPA OS_InpBuf+25 BCC e_goon BNE e_alldone     ; wurde bereits über existing data hinaus geschrieben?
                        LDA OS_PtrC+0 CPA OS_InpBuf+24 BCS e_alldone                        
  e_goon:                 ; restore the pointers A and C properly
                          LDI $10 ADB OS_InpBuf+23                                ; increment the sector address to write to
                          LDI <OS_SSDRAMBuf STA OS_PtrC+0                         ; PtrC: SSD buffer start in RAM
                          LDI >OS_SSDRAMBuf STA OS_PtrC+1
                          LDA OS_InpBuf+20 STA OS_PtrA+0                          ; PtrA: restore pointer to next data to keep
                          LDA OS_InpBuf+21 STA OS_PtrA+1 
                          JPA e_copyloop2                                         ; process next whole block
  e_alldone:          LDI 10 OUT JPS OS_WaitUART                                  ; ALLES FERTIG!
                      JPA OS_LineStart


; ************************************************************************
; Eraseses a 4KB FLASH memory block without ANY protection (use with care)
; PtrA: address of FLASH block to be erased to $ff, PtrA remains unchanged
; only the upper nibble of the MSB is relevant here
; ************************************************************************
FLASH_Erase:      LDI $aa STA $5555                           ; issue FLASH ERASE COMMAND
                  LDI $55 STA $2aaa
                  LDI $80 STA $5555
                  LDI $aa STA $5555
                  LDI $55 STA $2aaa
                  LDI $30 STR OS_PtrA                         ; initiate the BLOCK ERASE command
  fe_wait:    	  LDR OS_PtrA LSL BCC fe_wait                 ; wait for 8th bit go HIGH, this code HAS to run in RAM!
                    RTS

; **********************************************************
; Load file from SSD, modifies: ParsePtr, PtrA, PtrB, PtrC
; OS_ParsePtr: <filename> (0- or ENTER-terminated)
; OS_ParseNum: Custom data start address (ignored if <$8000)
; return: *(SP-2) = 1: success, = 0: failure
; **********************************************************
SSD_LoadFile:       JPS SSD_FindFile
                    LDS -2 CPI 0 BEQ OS_ReturnFalse                                 ; file pointer in PtrA valid?
                      LDA OS_ParseNum+1 CPI $80 BCC lf_extractstart                 ; custom Startaddresse gewünscht?
                        STA OS_PtrC+1 LDA OS_ParseNum+0 STA OS_PtrC+0               ; use custom start address
                        LDI 22 ADW OS_PtrA                                          ; advance to bytesize
                        JPA lf_extractsize
  lf_extractstart:    LDI 20 ADW OS_PtrA                                            ; advance over header to start addr LSB
                      LDR OS_PtrA STA OS_PtrC+0 STA OS_MemAddr+0 INW OS_PtrA        ; extract destination -> PtrC & OS_MemAddr
                      LDR OS_PtrA STA OS_PtrC+1 STA OS_MemAddr+1 INW OS_PtrA        
  lf_extractsize:     LDR OS_PtrA STA OS_PtrB+0 INW OS_PtrA                         ; extract bytesize -> PtrB
                      LDR OS_PtrA STA OS_PtrB+1 INW OS_PtrA                         ; PtrA now holds source address
  lf_next:            DEW OS_PtrB BCC OS_ReturnTrue						                      ; alles kopiert?
                        LDR OS_PtrA STR OS_PtrC								                      ; copy block from A -> to C
                        INW OS_PtrA INW OS_PtrC
                        JPA lf_next

; *************************************************************************************************
; Save specified data as file with header to the SSD drive
; PtrA: Address of first data byte , PtrB: Address of last data byte, PtrC: SSD address to write to
; ParsePtr: Start of valid file name (ENTER- or 0-terminated)
; *************************************************************************************************
SSD_SaveFile:     ; ***** prepare the header at the start of OS_ParsePtr inside OS_InpBuf
                  LDI 19 STA OS_Count                                 ; <19-char filename> and terminating 0 schreiben
  scanloop:       LDR OS_ParsePtr
                  CPI 10 BEQ prepexit CPI 0 BEQ prepexit              ; ENTER or 0 terminated
                    INW OS_ParsePtr
                    DEB OS_Count BNE scanloop
  prepexit:       LDI 0 STR OS_ParsePtr                               ; überschreibe ENTER und Rest mit 0
                    INW OS_ParsePtr
                    DEB OS_Count BCS prepexit                         ; 20th byte of filename is always zero!            
                  LDA OS_PtrA+1 SBB OS_PtrB+1 BCC OS_ReturnFalse      ; calculate bytesize N = B - A + 1
                  LDA OS_PtrA+0 SBW OS_PtrB BCC OS_ReturnFalse
                    INW OS_PtrB                                       ; add one
                  LDA OS_PtrA+0 STR OS_ParsePtr INW OS_ParsePtr       ; write start addr to header
                  LDA OS_PtrA+1 STR OS_ParsePtr INW OS_ParsePtr
                  LDA OS_PtrB+0 STR OS_ParsePtr INW OS_ParsePtr       ; write bytesize to header
                  LDA OS_PtrB+1 STR OS_ParsePtr INW OS_ParsePtr
                  ; ***** write header to FLASH                  
                  LDI 24 SBW OS_ParsePtr                              ; rewind to start of header
                  LDA OS_ParsePtr+0 STA OS_PtrA+0                     ; setup start addr of header in PtrA
                  LDA OS_ParsePtr+1 STA OS_PtrA+1
                  CLB OS_PtrB+1 LDI 24 STA OS_PtrB+0                  ; write bytesize of header
                  JPS SSD_Write                                       ; write the header to OS_PtrC, increasing it
                  LDA OS_PtrB+1 CPI $ff BNE OS_ReturnFalse            ; check error state
                  ; ***** write body to FLASH right after the header
                  LDI 20 ADW OS_ParsePtr                              ; jump to start addr in header
                  LDR OS_ParsePtr STA OS_PtrA+0 INW OS_ParsePtr       ; restore start address in RAM
                  LDR OS_ParsePtr STA OS_PtrA+1 INW OS_ParsePtr
                  LDR OS_ParsePtr STA OS_PtrB+0 INW OS_ParsePtr       ; restore byte size
                  LDR OS_ParsePtr STA OS_PtrB+1 INW OS_ParsePtr
                  JPS SSD_Write                                       ; write the header
                  LDA OS_PtrB+1 CPI $ff BNE OS_ReturnFalse            ; check error state
                    JPA OS_ReturnTrue

; *********************************************************************
; Writes data to SSD securely, PtrA: source, PtrB: bytesize, PtrC: dest
; SUCCESS <=> *(PtrB+1) = $ff
; modifies: PtrB ($ffff: success, else failure)
;           PtrA (points to byte after source data if successful)
;           PtrC (points to byte after target data if successful)
; protects FLASH areas $0-fff and $8000-ffff
; *********************************************************************
SSD_Write:        DEW OS_PtrB BCC fw_return                     ; Anzahl runterzählen
                    LDA OS_PtrC+1
                    CPI >OS_SSDStart BCC fw_return              ; teste, ob dest addr im OS-ROM liegt
                    CPI $80 BCS fw_return                       ; teste, ob dest addr >= $8000 liegt (RAM)
                    LDR OS_PtrC CPI $ff BNE fw_return           ; teste, ob dest byte == $ff ist
                    LDI $aa STA $5555                           ; INIT FLASH WRITE PROGRAM
                    LDI $55 STA $2aaa
                    LDI $a0 STA $5555
                    LDR OS_PtrA STR OS_PtrC									    ; write process "from" into FLASH
                    NOP NOP NOP                                 ; wait 26µs (byte prog time max. 20µs)
                    CPR OS_PtrC BNE fw_return                   ; RM vom FLASH okay?
                      INW OS_PtrA INW OS_PtrC                   ; increase both pointers to next location
                      JPA SSD_Write
  fw_return:        RTS

; ************************************************************************************
; Find first FREE byte in SSD by skipping over all filenames,
; returns pointer in OS_PtrC (>=$8000 if nothing is free),
; modifies: PtrC, PtrD
; ************************************************************************************
SSD_FindFree:     LDI <OS_SSDStart STA OS_PtrC+0
                  LDI >OS_SSDStart STA OS_PtrC+1                      ; look at beginning of SSD area
  ffree_loop:     LDA OS_PtrC+1 CPI $80 BCS ffree_return              ; return >=$8000
                  LDR OS_PtrC CPI $ff BEQ ffree_return                ; return with free diskspace
                    LDI 22 ADW OS_PtrC                                ; advance over header to bytesize info
                    LDR OS_PtrC STA OS_PtrD+0 INW OS_PtrC             ; read out the bytesize of this file
                    LDR OS_PtrC STA OS_PtrD+1 INW OS_PtrC             ; PtrC now points right after header
                    LDA OS_PtrD+1 ADB OS_PtrC+1                       ; add the bytesize to OS_PtrC
                    LDA OS_PtrD+0 ADW OS_PtrC+0
                    JPA ffree_loop
  ffree_return:   RTS

; *********************************************************************************
; Find <filename> at OS_ParsePtr, OS_PtrA returns file pointer (check for SUCCESS!)
; Note: <filename> may have leading spaces, must be either 0- or ENTER-terminated
; modifies: ParsePtr, PtrA, PtrB, PtrC
; *********************************************************************************
SSD_FindFile:     LDR OS_ParsePtr
                  CPI 0 BEQ OS_ReturnFalse                                        ; parse for beginning of valid filename
                  CPI 10 BEQ OS_ReturnFalse
                  CPI 32 BNE ff_nameok                                            ; skip over leading spaces
                    INW OS_ParsePtr JPA SSD_FindFile
                  ; browse through all stored files and see if filename matches name, any zero stops
  ff_nameok:      LDI <OS_SSDStart STA OS_PtrA+0 LDI >OS_SSDStart STA OS_PtrA+1   ; PtrA -> start of SSD area
  ff_search:      LDA OS_PtrA+1 CPI $80 BCS OS_ReturnFalse                        ; end of SSD reached -> no match!
                  LDR OS_PtrA CPI $ff BEQ OS_ReturnFalse                          ; end of file data reached -> no match!
                    ; check if name matches
                    LDA OS_PtrA+0 STA OS_PtrC+0 LDA OS_PtrA+1 STA OS_PtrC+1       ; copy address of file A -> C
                    LDA OS_ParsePtr+0 STA OS_PtrB+0                               ; copy address of filename -> B
                    LDA OS_ParsePtr+1 STA OS_PtrB+1                    
  match_loop:       LDR OS_PtrB CPI 10 BNE trymatch                               ; tausche ENTER gegen 0 aus
                      LDI 0
  trymatch:         CPR OS_PtrC BNE files_dont                                    ; stimmen Buchstaben überein?
                      CPI 0 BEQ OS_ReturnTrue                                     ; wurde gemeinsame 0 erreicht => match!
                        INW OS_PtrB INW OS_PtrC                                   ; sonst gehe zum nächsten
                        JPA match_loop
                    ; ***** these filenames don't match *****
  files_dont:       LDI 22 ADW OS_PtrA                                            ; advance over header to bytesize LSB
                    LDR OS_PtrA STA OS_PtrB+0 INW OS_PtrA                         ; extract bytesize -> PtrB
                    LDR OS_PtrA STA OS_PtrB+1 INW OS_PtrA
                    LDA OS_PtrB+1 ADB OS_PtrA+1 LDA OS_PtrB+0 ADW OS_PtrA         ; PtrA points beyond file
                    JPA ff_search

; *********************************************
; This section contains all text and other data
; *********************************************
  mnemonics:	  "NOP", "BNK", "OUT", "CLC", "SEC", "LSL", "ROL", "LSR", "ROR", "ASR", "INP", "NEG", "INC", "DEC"
                "LDI", "ADI", "SBI", "CPI", "ACI", "SCI"
                "JPA", "LDA", "STA", "ADA", "SBA", "CPA", "ACA", "SCA"
                "JPR", "LDR", "STR", "ADR", "SBR", "CPR", "ACR", "SCR"
                "CLB", "NEB", "INB", "DEB", "ADB", "SBB", "ACB", "SCB"
                "CLW", "NEW", "INW", "DEW", "ADW", "SBW", "ACW", "SCW"
                "LDS", "STS", "PHS", "PLS", "JPS", "RTS"
                "BNE", "BEQ", "BCC", "BCS", "BPL", "BMI"
                
  oplength:     0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; operator byte length
                1,1,1,1,1,1
                2,2,2,2,2,2,2,2
                2,2,2,2,2,2,2,2
                2,2,2,2,2,2,2,2
                2,2,2,2,2,2,2,2
                -1,-1,0,0,2,0
                2,2,2,2,2,2
								
  welcometxt: 	27, "[H", 27, "[H", 27, "[J"
                "+--------------------------------------+", 10
                "| MINIMAL CPU SYSTEM 1.5 by C. Herting |", 10
                "| 32KB RAM 512KB SSD - Type m for menu |", 10
                "+--------------------------------------+", 10
                0
  menutxt:      10,
                "COMMAND....... DESCRIPTION..............", 10
                "1[234][ r]     Set HEX addr A [and run]", 10
                "[A].B          Show RAM [A]..B [q quits]", 10
                ":C[ D ..]      Deposit C [D ..] at A..", 10
                "v A B C        Fill RAM A..B with C", 10
                "k A B C        Copy A..B to RAM C..", 10
                "i A            Disassemble A.. [q quits]", 10
                "w              Wipe SSD bank", 10
                "s A B file     Save A..B as file to SSD", 10
                "l file         Load file from SSD", 10
                "z file         Zap file from SSD", 10
                "t              SSD Table of content", 10
                "n A            Select SSD bank 0..f", 10
                10, 0

  dirtext:      10
                "FILENAME........... ADDR SIZE", 10, 0
  coltext:      27, "[21G", 0
  freetext:     27, "[21GFREE ", 0
  suretext:     "[y/n]?", 10, 0

#end 

*=$0000   OS_SSDStart:                          ; Beginning of SSD drive (goes up to $7fff in each bank)
*=$e000   OS_SSDRAMBuf:                         ; 4KB buffer used to mirror SSD blocks when moving files
*=$ff00   OS_MemAddr:                           ; CURRENT ADDRESS IN MEMMON (16 bytes von MINOS am unteren Ende des Stack)
*=$ff02   OS_ParsePtr:                          ; Zeiger auf das letzte eingelesene Zeichen (to be reset at startup)
*=$ff04   OS_ParseNum:                          ; 3-byte storage for a parsed 16-bit number, MSB: f0=invalid, 0=valid
*=$ff07   OS_Mode:                              ; byte 0: normal, 1: deposit, 2: list
*=$ff08   OS_Count:                             ; lokaler byte counter
*=$ff09   OS_PtrA:                              ; lokaler pointer
*=$ff0b   OS_PtrB:                              ; lokaler pointer, Zeiger auf mnemonic input position                          ; 
*=$ff0d   OS_PtrC:                              ; lokaler pointer, reuse as byte line counter & 3-byte-Speicher für mnemonic
*=$ff10   OS_PtrD:                              ; lokaler pointer
*=$ff12   OS_InpBuf:                            ; 110 bytes line input string (also used by FLASH erase monitor)
*=$fffe   OS_TopOfStack:                        ; Stack grows downwards (max 256 bytes)
*=$ffff   OS_StackPointer:                      ; Processor stack pointer holding LSB current top of stack
